/* window.c generated by valac 0.48.9, the Vala compiler
 * generated from window.vala, do not modify */

/* window.vala
 *
 * Copyright 2020 munchkinhalfling
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <gtk/gtk.h>
#include <glib-object.h>
#include <glib.h>
#include <vte/vte.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#define TABTERM_TYPE_WINDOW (tabterm_window_get_type ())
#define TABTERM_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TABTERM_TYPE_WINDOW, TabtermWindow))
#define TABTERM_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TABTERM_TYPE_WINDOW, TabtermWindowClass))
#define TABTERM_IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TABTERM_TYPE_WINDOW))
#define TABTERM_IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TABTERM_TYPE_WINDOW))
#define TABTERM_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TABTERM_TYPE_WINDOW, TabtermWindowClass))

typedef struct _TabtermWindow TabtermWindow;
typedef struct _TabtermWindowClass TabtermWindowClass;
typedef struct _TabtermWindowPrivate TabtermWindowPrivate;
enum  {
	TABTERM_WINDOW_0_PROPERTY,
	TABTERM_WINDOW_NUM_PROPERTIES
};
static GParamSpec* tabterm_window_properties[TABTERM_WINDOW_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _TabtermWindow {
	GtkApplicationWindow parent_instance;
	TabtermWindowPrivate * priv;
};

struct _TabtermWindowClass {
	GtkApplicationWindowClass parent_class;
};

struct _TabtermWindowPrivate {
	GtkStack* terminals;
	GtkButton* addTerminal;
	gint curTerm;
};

static gint TabtermWindow_private_offset;
static gpointer tabterm_window_parent_class = NULL;

GType tabterm_window_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (TabtermWindow, g_object_unref)
TabtermWindow* tabterm_window_new (GtkApplication* app);
TabtermWindow* tabterm_window_construct (GType object_type,
                                         GtkApplication* app);
void tabterm_window_newTerminal (TabtermWindow* self);
static void _tabterm_window_newTerminal_gtk_button_clicked (GtkButton* _sender,
                                                     gpointer self);
static void tabterm_window_finalize (GObject * obj);
static GType tabterm_window_get_type_once (void);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);

static inline gpointer
tabterm_window_get_instance_private (TabtermWindow* self)
{
	return G_STRUCT_MEMBER_P (self, TabtermWindow_private_offset);
}

static void
_tabterm_window_newTerminal_gtk_button_clicked (GtkButton* _sender,
                                                gpointer self)
{
#line 31 "../src/window.vala"
	tabterm_window_newTerminal ((TabtermWindow*) self);
#line 97 "window.c"
}

TabtermWindow*
tabterm_window_construct (GType object_type,
                          GtkApplication* app)
{
	TabtermWindow * self = NULL;
	GtkButton* _tmp0_;
	GtkStack* _tmp1_;
#line 29 "../src/window.vala"
	g_return_val_if_fail (app != NULL, NULL);
#line 30 "../src/window.vala"
	self = (TabtermWindow*) g_object_new (object_type, "application", app, NULL);
#line 31 "../src/window.vala"
	_tmp0_ = self->priv->addTerminal;
#line 31 "../src/window.vala"
	g_signal_connect_object (_tmp0_, "clicked", (GCallback) _tabterm_window_newTerminal_gtk_button_clicked, self, 0);
#line 32 "../src/window.vala"
	_tmp1_ = self->priv->terminals;
#line 32 "../src/window.vala"
	gtk_stack_set_transition_type (_tmp1_, GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT);
#line 29 "../src/window.vala"
	return self;
#line 121 "window.c"
}

TabtermWindow*
tabterm_window_new (GtkApplication* app)
{
#line 29 "../src/window.vala"
	return tabterm_window_construct (TABTERM_TYPE_WINDOW, app);
#line 129 "window.c"
}

void
tabterm_window_newTerminal (TabtermWindow* self)
{
	VteTerminal* term = NULL;
	VteTerminal* _tmp0_;
	gchar* command = NULL;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	GtkStack* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	FILE* _tmp19_;
	gchar* _tmp20_;
	gchar* _tmp21_;
	gchar* _tmp22_;
	gchar* _tmp23_;
	gchar* _tmp24_;
	gchar* _tmp25_;
	gint _tmp26_;
	GError* _inner_error0_ = NULL;
#line 35 "../src/window.vala"
	g_return_if_fail (self != NULL);
#line 36 "../src/window.vala"
	_tmp0_ = (VteTerminal*) vte_terminal_new ();
#line 36 "../src/window.vala"
	g_object_ref_sink (_tmp0_);
#line 36 "../src/window.vala"
	term = _tmp0_;
#line 37 "../src/window.vala"
	_tmp1_ = g_getenv ("SHELL");
#line 37 "../src/window.vala"
	_tmp2_ = g_strdup (_tmp1_);
#line 37 "../src/window.vala"
	command = _tmp2_;
#line 172 "window.c"
	{
		const gchar* _tmp3_;
		gchar* _tmp4_;
		gchar** _tmp5_;
		gchar** _tmp6_;
		gint _tmp6__length1;
#line 39 "../src/window.vala"
		_tmp3_ = g_getenv ("HOME");
#line 39 "../src/window.vala"
		_tmp4_ = g_strdup (command);
#line 39 "../src/window.vala"
		_tmp5_ = g_new0 (gchar*, 1 + 1);
#line 39 "../src/window.vala"
		_tmp5_[0] = _tmp4_;
#line 39 "../src/window.vala"
		_tmp6_ = _tmp5_;
#line 39 "../src/window.vala"
		_tmp6__length1 = 1;
#line 39 "../src/window.vala"
		vte_terminal_spawn_sync (term, VTE_PTY_DEFAULT, _tmp3_, _tmp6_, NULL, 0, NULL, NULL, NULL, NULL, &_inner_error0_);
#line 39 "../src/window.vala"
		_tmp6_ = (_vala_array_free (_tmp6_, _tmp6__length1, (GDestroyNotify) g_free), NULL);
#line 39 "../src/window.vala"
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 197 "window.c"
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp7_;
		GError* _tmp8_;
		const gchar* _tmp9_;
#line 38 "../src/window.vala"
		e = _inner_error0_;
#line 38 "../src/window.vala"
		_inner_error0_ = NULL;
#line 49 "../src/window.vala"
		_tmp7_ = stderr;
#line 49 "../src/window.vala"
		_tmp8_ = e;
#line 49 "../src/window.vala"
		_tmp9_ = _tmp8_->message;
#line 49 "../src/window.vala"
		fprintf (_tmp7_, "Error: %s\n", _tmp9_);
#line 38 "../src/window.vala"
		_g_error_free0 (e);
#line 222 "window.c"
	}
	__finally0:
#line 38 "../src/window.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 38 "../src/window.vala"
		_g_free0 (command);
#line 38 "../src/window.vala"
		_g_object_unref0 (term);
#line 38 "../src/window.vala"
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 38 "../src/window.vala"
		g_clear_error (&_inner_error0_);
#line 38 "../src/window.vala"
		return;
#line 237 "window.c"
	}
#line 52 "../src/window.vala"
	_tmp10_ = self->priv->terminals;
#line 52 "../src/window.vala"
	_tmp11_ = g_strdup_printf ("%i", self->priv->curTerm);
#line 52 "../src/window.vala"
	_tmp12_ = _tmp11_;
#line 52 "../src/window.vala"
	_tmp13_ = g_strconcat ("term", _tmp12_, NULL);
#line 52 "../src/window.vala"
	_tmp14_ = _tmp13_;
#line 52 "../src/window.vala"
	_tmp15_ = g_strdup_printf ("%i", self->priv->curTerm);
#line 52 "../src/window.vala"
	_tmp16_ = _tmp15_;
#line 52 "../src/window.vala"
	_tmp17_ = g_strconcat ("Terminal ", _tmp16_, NULL);
#line 52 "../src/window.vala"
	_tmp18_ = _tmp17_;
#line 52 "../src/window.vala"
	gtk_stack_add_titled (_tmp10_, (GtkWidget*) term, _tmp14_, _tmp18_);
#line 52 "../src/window.vala"
	_g_free0 (_tmp18_);
#line 52 "../src/window.vala"
	_g_free0 (_tmp16_);
#line 52 "../src/window.vala"
	_g_free0 (_tmp14_);
#line 52 "../src/window.vala"
	_g_free0 (_tmp12_);
#line 53 "../src/window.vala"
	_tmp19_ = stdout;
#line 53 "../src/window.vala"
	_tmp20_ = g_strdup_printf ("%i", self->priv->curTerm);
#line 53 "../src/window.vala"
	_tmp21_ = _tmp20_;
#line 53 "../src/window.vala"
	_tmp22_ = g_strconcat ("New terminal: ", _tmp21_, NULL);
#line 53 "../src/window.vala"
	_tmp23_ = _tmp22_;
#line 53 "../src/window.vala"
	_tmp24_ = g_strconcat (_tmp23_, "\n", NULL);
#line 53 "../src/window.vala"
	_tmp25_ = _tmp24_;
#line 53 "../src/window.vala"
	fprintf (_tmp19_, "%s", _tmp25_);
#line 53 "../src/window.vala"
	_g_free0 (_tmp25_);
#line 53 "../src/window.vala"
	_g_free0 (_tmp23_);
#line 53 "../src/window.vala"
	_g_free0 (_tmp21_);
#line 54 "../src/window.vala"
	gtk_widget_show_all ((GtkWidget*) self);
#line 55 "../src/window.vala"
	_tmp26_ = self->priv->curTerm;
#line 55 "../src/window.vala"
	self->priv->curTerm = _tmp26_ + 1;
#line 35 "../src/window.vala"
	_g_free0 (command);
#line 35 "../src/window.vala"
	_g_object_unref0 (term);
#line 299 "window.c"
}

static void
tabterm_window_class_init (TabtermWindowClass * klass,
                           gpointer klass_data)
{
#line 21 "../src/window.vala"
	tabterm_window_parent_class = g_type_class_peek_parent (klass);
#line 21 "../src/window.vala"
	g_type_class_adjust_private_offset (klass, &TabtermWindow_private_offset);
#line 21 "../src/window.vala"
	G_OBJECT_CLASS (klass)->finalize = tabterm_window_finalize;
#line 21 "../src/window.vala"
	gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass), "/com/github/munchkinhalfling/tabterm/window.ui");
#line 21 "../src/window.vala"
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "terminals", FALSE, TabtermWindow_private_offset + G_STRUCT_OFFSET (TabtermWindowPrivate, terminals));
#line 21 "../src/window.vala"
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "addTerminal", FALSE, TabtermWindow_private_offset + G_STRUCT_OFFSET (TabtermWindowPrivate, addTerminal));
#line 318 "window.c"
}

static void
tabterm_window_instance_init (TabtermWindow * self,
                              gpointer klass)
{
#line 21 "../src/window.vala"
	self->priv = tabterm_window_get_instance_private (self);
#line 27 "../src/window.vala"
	self->priv->curTerm = 0;
#line 21 "../src/window.vala"
	gtk_widget_init_template (GTK_WIDGET (self));
#line 331 "window.c"
}

static void
tabterm_window_finalize (GObject * obj)
{
	TabtermWindow * self;
#line 21 "../src/window.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TABTERM_TYPE_WINDOW, TabtermWindow);
#line 23 "../src/window.vala"
	_g_object_unref0 (self->priv->terminals);
#line 25 "../src/window.vala"
	_g_object_unref0 (self->priv->addTerminal);
#line 21 "../src/window.vala"
	G_OBJECT_CLASS (tabterm_window_parent_class)->finalize (obj);
#line 346 "window.c"
}

static GType
tabterm_window_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (TabtermWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) tabterm_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TabtermWindow), 0, (GInstanceInitFunc) tabterm_window_instance_init, NULL };
	GType tabterm_window_type_id;
	tabterm_window_type_id = g_type_register_static (gtk_application_window_get_type (), "TabtermWindow", &g_define_type_info, 0);
	TabtermWindow_private_offset = g_type_add_instance_private (tabterm_window_type_id, sizeof (TabtermWindowPrivate));
	return tabterm_window_type_id;
}

GType
tabterm_window_get_type (void)
{
	static volatile gsize tabterm_window_type_id__volatile = 0;
	if (g_once_init_enter (&tabterm_window_type_id__volatile)) {
		GType tabterm_window_type_id;
		tabterm_window_type_id = tabterm_window_get_type_once ();
		g_once_init_leave (&tabterm_window_type_id__volatile, tabterm_window_type_id);
	}
	return tabterm_window_type_id__volatile;
}

static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gint i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

